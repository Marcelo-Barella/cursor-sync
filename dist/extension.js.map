{
  "version": 3,
  "sources": ["../node_modules/balanced-match/src/index.ts", "../node_modules/brace-expansion/src/index.ts", "../node_modules/minimatch/src/assert-valid-pattern.ts", "../node_modules/minimatch/src/brace-expressions.ts", "../node_modules/minimatch/src/unescape.ts", "../node_modules/minimatch/src/ast.ts", "../node_modules/minimatch/src/escape.ts", "../node_modules/minimatch/src/index.ts", "../src/paths.ts", "../src/extension.ts", "../src/auth.ts", "../src/gist.ts", "../src/retry.ts", "../src/diagnostics.ts", "../src/push.ts", "../src/packaging.ts", "../src/conflicts.ts", "../src/extensions.ts", "../src/pull.ts", "../src/rollback.ts", "../src/scheduler.ts"],
  "sourcesContent": ["export const balanced = (\n  a: string | RegExp,\n  b: string | RegExp,\n  str: string,\n) => {\n  const ma = a instanceof RegExp ? maybeMatch(a, str) : a\n  const mb = b instanceof RegExp ? maybeMatch(b, str) : b\n\n  const r = ma !== null && mb != null && range(ma, mb, str)\n\n  return (\n    r && {\n      start: r[0],\n      end: r[1],\n      pre: str.slice(0, r[0]),\n      body: str.slice(r[0] + ma.length, r[1]),\n      post: str.slice(r[1] + mb.length),\n    }\n  )\n}\n\nconst maybeMatch = (reg: RegExp, str: string) => {\n  const m = str.match(reg)\n  return m ? m[0] : null\n}\n\nexport const range = (\n  a: string,\n  b: string,\n  str: string,\n): undefined | [number, number] => {\n  let begs: number[],\n    beg: number | undefined,\n    left: number,\n    right: number | undefined = undefined,\n    result: undefined | [number, number]\n  let ai = str.indexOf(a)\n  let bi = str.indexOf(b, ai + 1)\n  let i = ai\n\n  if (ai >= 0 && bi > 0) {\n    if (a === b) {\n      return [ai, bi]\n    }\n    begs = []\n    left = str.length\n\n    while (i >= 0 && !result) {\n      if (i === ai) {\n        begs.push(i)\n        ai = str.indexOf(a, i + 1)\n      } else if (begs.length === 1) {\n        const r = begs.pop()\n        if (r !== undefined) result = [r, bi]\n      } else {\n        beg = begs.pop()\n        if (beg !== undefined && beg < left) {\n          left = beg\n          right = bi\n        }\n\n        bi = str.indexOf(b, i + 1)\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi\n    }\n\n    if (begs.length && right !== undefined) {\n      result = [left, right]\n    }\n  }\n\n  return result\n}\n", "import { balanced } from 'balanced-match'\n\nconst escSlash = '\\0SLASH' + Math.random() + '\\0'\nconst escOpen = '\\0OPEN' + Math.random() + '\\0'\nconst escClose = '\\0CLOSE' + Math.random() + '\\0'\nconst escComma = '\\0COMMA' + Math.random() + '\\0'\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0'\nconst escSlashPattern = new RegExp(escSlash, 'g')\nconst escOpenPattern = new RegExp(escOpen, 'g')\nconst escClosePattern = new RegExp(escClose, 'g')\nconst escCommaPattern = new RegExp(escComma, 'g')\nconst escPeriodPattern = new RegExp(escPeriod, 'g')\nconst slashPattern = /\\\\\\\\/g\nconst openPattern = /\\\\{/g\nconst closePattern = /\\\\}/g\nconst commaPattern = /\\\\,/g\nconst periodPattern = /\\\\./g\n\nexport const EXPANSION_MAX = 100_000\n\nfunction numeric(str: string) {\n  return !isNaN(str as any) ? parseInt(str, 10) : str.charCodeAt(0)\n}\n\nfunction escapeBraces(str: string) {\n  return str\n    .replace(slashPattern, escSlash)\n    .replace(openPattern, escOpen)\n    .replace(closePattern, escClose)\n    .replace(commaPattern, escComma)\n    .replace(periodPattern, escPeriod)\n}\n\nfunction unescapeBraces(str: string) {\n  return str\n    .replace(escSlashPattern, '\\\\')\n    .replace(escOpenPattern, '{')\n    .replace(escClosePattern, '}')\n    .replace(escCommaPattern, ',')\n    .replace(escPeriodPattern, '.')\n}\n\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str: string) {\n  if (!str) {\n    return ['']\n  }\n\n  const parts: string[] = []\n  const m = balanced('{', '}', str)\n\n  if (!m) {\n    return str.split(',')\n  }\n\n  const { pre, body, post } = m\n  const p = pre.split(',')\n\n  p[p.length - 1] += '{' + body + '}'\n  const postParts = parseCommaParts(post)\n  if (post.length) {\n    ;(p[p.length - 1] as string) += postParts.shift()\n    p.push.apply(p, postParts)\n  }\n\n  parts.push.apply(parts, p)\n\n  return parts\n}\n\nexport type BraceExpansionOptions = {\n  max?: number\n}\n\nexport function expand(str: string, options: BraceExpansionOptions = {}) {\n  if (!str) {\n    return []\n  }\n\n  const { max = EXPANSION_MAX } = options\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.slice(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.slice(2)\n  }\n\n  return expand_(escapeBraces(str), max, true).map(unescapeBraces)\n}\n\nfunction embrace(str: string) {\n  return '{' + str + '}'\n}\n\nfunction isPadded(el: string) {\n  return /^-?0\\d/.test(el)\n}\n\nfunction lte(i: number, y: number) {\n  return i <= y\n}\n\nfunction gte(i: number, y: number) {\n  return i >= y\n}\n\nfunction expand_(str: string, max: number, isTop: boolean): string[] {\n  /** @type {string[]} */\n  const expansions: string[] = []\n\n  const m = balanced('{', '}', str)\n  if (!m) return [str]\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  const pre = m.pre\n  const post: string[] = m.post.length ? expand_(m.post, max, false) : ['']\n\n  if (/\\$$/.test(m.pre)) {\n    for (let k = 0; k < post.length && k < max; k++) {\n      const expansion = pre + '{' + m.body + '}' + post[k]\n      expansions.push(expansion)\n    }\n  } else {\n    const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(\n      m.body,\n    )\n    const isSequence = isNumericSequence || isAlphaSequence\n    const isOptions = m.body.indexOf(',') >= 0\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,(?!,).*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post\n        return expand_(str, max, true)\n      }\n      return [str]\n    }\n\n    let n: string[]\n    if (isSequence) {\n      n = m.body.split(/\\.\\./)\n    } else {\n      n = parseCommaParts(m.body)\n      if (n.length === 1 && n[0] !== undefined) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand_(n[0], max, false).map(embrace)\n        //XXX is this necessary? Can't seem to hit it in tests.\n        /* c8 ignore start */\n        if (n.length === 1) {\n          return post.map(p => m.pre + n[0] + p)\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    let N: string[]\n\n    if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n      const x = numeric(n[0])\n      const y = numeric(n[1])\n      const width = Math.max(n[0].length, n[1].length)\n      let incr =\n        n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1\n      let test = lte\n      const reverse = y < x\n      if (reverse) {\n        incr *= -1\n        test = gte\n      }\n      const pad = n.some(isPadded)\n\n      N = []\n\n      for (let i = x; test(i, y); i += incr) {\n        let c\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i)\n          if (c === '\\\\') {\n            c = ''\n          }\n        } else {\n          c = String(i)\n          if (pad) {\n            const need = width - c.length\n            if (need > 0) {\n              const z = new Array(need + 1).join('0')\n              if (i < 0) {\n                c = '-' + z + c.slice(1)\n              } else {\n                c = z + c\n              }\n            }\n          }\n        }\n        N.push(c)\n      }\n    } else {\n      N = []\n\n      for (let j = 0; j < n.length; j++) {\n        N.push.apply(N, expand_(n[j] as string, max, false))\n      }\n    }\n\n    for (let j = 0; j < N.length; j++) {\n      for (let k = 0; k < post.length && expansions.length < max; k++) {\n        const expansion = pre + N[j] + post[k]\n        if (!isTop || isSequence || expansion) {\n          expansions.push(expansion)\n        }\n      }\n    }\n  }\n\n  return expansions\n}\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: unknown) => void = (\n  pattern: unknown,\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } =\n  {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n  }\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean,\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number,\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length ? '(' + sranges + '|' + snegs + ')'\n    : ranges.length ? sranges\n    : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link MinimatchOptions.windowsPathsNoEscape} option is used, then\n * square-bracket escapes are removed, but not backslash escapes.\n *\n * For example, it will turn the string `'[*]'` into `*`, but it will not\n * turn `'\\\\*'` into `'*'`, because `\\` is a path separator in\n * `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both square-bracket escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n *\n * When `magicalBraces` is not set, escapes of braces (`{` and `}`) will not be\n * unescaped.\n */\n\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n    magicalBraces = true,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape' | 'magicalBraces'> = {},\n) => {\n  if (magicalBraces) {\n    return windowsPathsNoEscape ?\n        s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n      : s\n          .replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2')\n          .replace(/\\\\([^\\/])/g, '$1')\n  }\n  return windowsPathsNoEscape ?\n      s.replace(/\\[([^\\/\\\\{}])\\]/g, '$1')\n    : s\n        .replace(/((?!\\\\).|^)\\[([^\\/\\\\{}])\\]/g, '$1$2')\n        .replace(/\\\\([^\\/{}])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string | null): c is ExtglobType =>\n  types.has(c as ExtglobType)\nconst isExtglobAST = (c: AST): c is AST & { type: ExtglobType } =>\n  isExtglobType(c.type)\n\n// Map of which extglob types can adopt the children of a nested extglob\n//\n// anything but ! can adopt a matching type:\n// +(a|+(b|c)|d) => +(a|b|c|d)\n// *(a|*(b|c)|d) => *(a|b|c|d)\n// @(a|@(b|c)|d) => @(a|b|c|d)\n// ?(a|?(b|c)|d) => ?(a|b|c|d)\n//\n// * can adopt anything, because 0 or repetition is allowed\n// *(a|?(b|c)|d) => *(a|b|c|d)\n// *(a|+(b|c)|d) => *(a|b|c|d)\n// *(a|@(b|c)|d) => *(a|b|c|d)\n//\n// + can adopt @, because 1 or repetition is allowed\n// +(a|@(b|c)|d) => +(a|b|c|d)\n//\n// + and @ CANNOT adopt *, because 0 would be allowed\n// +(a|*(b|c)|d) => would match \"\", on *(b|c)\n// @(a|*(b|c)|d) => would match \"\", on *(b|c)\n//\n// + and @ CANNOT adopt ?, because 0 would be allowed\n// +(a|?(b|c)|d) => would match \"\", on ?(b|c)\n// @(a|?(b|c)|d) => would match \"\", on ?(b|c)\n//\n// ? can adopt @, because 0 or 1 is allowed\n// ?(a|@(b|c)|d) => ?(a|b|c|d)\n//\n// ? and @ CANNOT adopt * or +, because >1 would be allowed\n// ?(a|*(b|c)|d) => would match bbb on *(b|c)\n// @(a|*(b|c)|d) => would match bbb on *(b|c)\n// ?(a|+(b|c)|d) => would match bbb on +(b|c)\n// @(a|+(b|c)|d) => would match bbb on +(b|c)\n//\n// ! CANNOT adopt ! (nothing else can either)\n// !(a|!(b|c)|d) => !(a|b|c|d) would fail to match on b (not not b|c)\n//\n// ! can adopt @\n// !(a|@(b|c)|d) => !(a|b|c|d)\n//\n// ! CANNOT adopt *\n// !(a|*(b|c)|d) => !(a|b|c|d) would match on bbb, not allowed\n//\n// ! CANNOT adopt +\n// !(a|+(b|c)|d) => !(a|b|c|d) would match on bbb, not allowed\n//\n// ! CANNOT adopt ?\n// x!(a|?(b|c)|d) => x!(a|b|c|d) would fail to match \"x\"\nconst adoptionMap = new Map<ExtglobType, ExtglobType[]>([\n  ['!', ['@']],\n  ['?', ['?', '@']],\n  ['@', ['@']],\n  ['*', ['*', '+', '?', '@']],\n  ['+', ['+', '@']],\n])\n\n// nested extglobs that can be adopted in, but with the addition of\n// a blank '' element.\nconst adoptionWithSpaceMap = new Map<ExtglobType, ExtglobType[]>([\n  ['!', ['?']],\n  ['@', ['?']],\n  ['+', ['?', '*']],\n])\n\n// union of the previous two maps\nconst adoptionAnyMap = new Map<ExtglobType, ExtglobType[]>([\n  ['!', ['?', '@']],\n  ['?', ['?', '@']],\n  ['@', ['?', '@']],\n  ['*', ['*', '+', '?', '@']],\n  ['+', ['+', '@', '?', '*']],\n])\n\n// Extglobs that can take over their parent if they are the only child\n// the key is parent, value maps child to resulting extglob parent type\n// '@' is omitted because it's a special case. An `@` extglob with a single\n// member can always be usurped by that subpattern.\nconst usurpMap = new Map<ExtglobType, Map<ExtglobType | null, ExtglobType | null>>([\n  ['!', new Map([['!', '@']])],\n  [\n    '?',\n    new Map([\n      ['*', '*'],\n      ['+', '*'],\n    ]),\n  ],\n  [\n    '@',\n    new Map([\n      ['!', '!'],\n      ['?', '?'],\n      ['@', '@'],\n      ['*', '*'],\n      ['+', '+'],\n    ]),\n  ],\n  [\n    '+',\n    new Map([\n      ['?', '*'],\n      ['*', '*'],\n    ]),\n  ],\n])\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nlet ID = 0\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  #parent?: AST\n  #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n  id = ++ID\n\n  get depth(): number {\n    return (this.#parent?.depth ?? -1) + 1\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return {\n      '@@type': 'AST',\n      id: this.id,\n      type: this.type,\n      root: this.#root.id,\n      parent: this.#parent?.id,\n      depth: this.depth,\n      partsLength: this.#parts.length,\n      parts: this.#parts,\n    }\n  }\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {},\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (\n        typeof p !== 'string' &&\n        !(p instanceof AST && p.#parent === this)\n      ) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null ?\n        this.#parts\n          .slice()\n          .map(p => (typeof p === 'string' ? p : p.toJSON()))\n      : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions,\n    extDepth: number,\n  ): number {\n    const maxDepth = opt.maxExtglobRecursion ?? 2\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        // we don't have to check for adoption here, because that's\n        // done at the other recursion point.\n        const doRecurse =\n          !opt.noext &&\n          isExtglobType(c) &&\n          str.charAt(i) === '(' &&\n          extDepth <= maxDepth\n        if (doRecurse) {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt, extDepth + 1)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      const doRecurse =\n        !opt.noext &&\n        isExtglobType(c) &&\n        str.charAt(i) === '(' &&\n        /* c8 ignore start - the maxDepth is sufficient here */\n        (extDepth <= maxDepth || (ast && ast.#canAdoptType(c)))\n      /* c8 ignore stop */\n      if (doRecurse) {\n        const depthAdd = ast && ast.#canAdoptType(c) ? 0 : 1\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt, extDepth + depthAdd)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  #canAdoptWithSpace(child?: AST | string): child is AST & {\n    type: null\n    parts: [AST & { type: ExtglobType }]\n  } {\n    return this.#canAdopt(child, adoptionWithSpaceMap)\n  }\n\n  #canAdopt(\n    child?: AST | string,\n    map: Map<ExtglobType, ExtglobType[]> = adoptionMap,\n  ): child is AST & {\n    type: null\n    parts: [AST & { type: ExtglobType }]\n  } {\n    if (\n      !child ||\n      typeof child !== 'object' ||\n      child.type !== null ||\n      child.#parts.length !== 1 ||\n      this.type === null\n    ) {\n      return false\n    }\n    const gc = child.#parts[0]\n    if (!gc || typeof gc !== 'object' || gc.type === null) {\n      return false\n    }\n    return (this as AST & { type: ExtglobType }).#canAdoptType(\n      gc.type,\n      map,\n    )\n  }\n  #canAdoptType(\n    c: string,\n    map: Map<ExtglobType, ExtglobType[]> = adoptionAnyMap,\n  ): c is ExtglobType {\n    return !!map.get(this.type as ExtglobType)?.includes(c as ExtglobType)\n  }\n\n  #adoptWithSpace(\n    this: AST & { type: ExtglobType },\n    child: AST & {\n      type: null\n    },\n    index: number,\n  ) {\n    const gc = child.#parts[0] as AST & { type: ExtglobType }\n    const blank = new AST(null, gc, this.options)\n    blank.#parts.push('')\n    gc.push(blank)\n    this.#adopt(child, index)\n  }\n\n  #adopt(\n    child: AST & {\n      type: null\n    },\n    index: number,\n  ) {\n    const gc = child.#parts[0] as AST & { type: ExtglobType }\n    this.#parts.splice(index, 1, ...gc.#parts)\n    for (const p of gc.#parts) {\n      if (typeof p === 'object') p.#parent = this\n    }\n    this.#toString = undefined\n  }\n\n  #canUsurpType(c: string): boolean {\n    const m = usurpMap.get(this.type as ExtglobType)\n    return !!(m?.has(c as ExtglobType))\n  }\n\n  #canUsurp (\n    child?: AST | string,\n  ): child is AST & {\n    type: null\n    parts: [AST & { type: ExtglobType }]\n  } {\n    if (\n      !child ||\n      typeof child !== 'object' ||\n      child.type !== null ||\n      child.#parts.length !== 1 ||\n      this.type === null ||\n      this.#parts.length !== 1\n    ) {\n      return false\n    }\n    const gc = child.#parts[0]\n    if (!gc || typeof gc !== 'object' || gc.type === null) {\n      return false\n    }\n    return (this as AST & { type: ExtglobType }).#canUsurpType(gc.type)\n  }\n\n  #usurp(this: AST & { type: ExtglobType }, child: AST & { type: null }) {\n    const m = usurpMap.get(this.type as ExtglobType)\n    const gc = child.#parts[0] as AST & { type: ExtglobType }\n    const nt = m?.get(gc.type)\n    /* c8 ignore start - impossible */\n    if (!nt) return false\n    /* c8 ignore stop */\n    this.#parts = gc.#parts\n    for (const p of this.#parts) {\n      if (typeof p === 'object') {\n        p.#parent = this\n      }\n    }\n    this.type = nt\n    this.#toString = undefined\n    this.#emptyExt = false\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options, 0)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean,\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) {\n      this.#flatten()\n      this.#fillNegs()\n    }\n    if (!isExtglobAST(this)) {\n      const noEmpty =\n        this.isStart() &&\n        this.isEnd() &&\n        !this.#parts.some(s => typeof s !== 'string')\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string' ?\n              AST.#parseGlob(p, this.#hasMagic, noEmpty)\n            : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start =\n              needNoTrav ? startNoTraversal\n              : needNoDot ? startNoDot\n              : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      const me = this as AST\n      me.#parts = [s]\n      me.type = null\n      me.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot ?\n        ''\n      : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!' ?\n          // !() must match something,but !(x) can match ''\n          '))' +\n          (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n          star +\n          ')'\n        : this.type === '@' ? ')'\n        : this.type === '?' ? ')?'\n        : this.type === '+' && bodyDotAllowed ? ')'\n        : this.type === '*' && bodyDotAllowed ? `)?`\n        : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #flatten() {\n    if (!isExtglobAST(this)) {\n      for (const p of this.#parts) {\n        if (typeof p === 'object') {\n          p.#flatten()\n        }\n      }\n    } else {\n      // do up to 10 passes to flatten as much as possible\n      let iterations = 0\n      let done = false\n      do {\n        done = true\n        for (let i = 0; i < this.#parts.length; i++) {\n          const c = this.#parts[i]\n          if (typeof c === 'object') {\n            c.#flatten()\n            if (this.#canAdopt(c)) {\n              done = false\n              this.#adopt(c, i)\n            } else if (this.#canAdoptWithSpace(c)) {\n              done = false\n              this.#adoptWithSpace(c, i)\n            } else if (this.#canUsurp(c)) {\n              done = false\n              this.#usurp(c)\n            }\n          }\n        }\n      } while (!done && ++iterations < 10)\n    }\n    this.#toString = undefined\n  }\n\n  #partsToRegExp(this: AST & { type: ExtglobType }, dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false,\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    // multiple stars that aren't globstars coalesce into one *\n    let inStar = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '*') {\n        if (inStar) continue\n        inStar = true\n        re += noEmpty && /^[*]+$/.test(glob) ? starNoEmpty : star\n        hasMagic = true\n        continue\n      } else {\n        inStar = false\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link MinimatchOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n *\n * If the {@link MinimatchOptions.magicalBraces} option is used,\n * then braces (`{` and `}`) will be escaped.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n    magicalBraces = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape' | 'magicalBraces'> = {},\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  if (magicalBraces) {\n    return windowsPathsNoEscape ?\n        s.replace(/[?*()[\\]{}]/g, '[$&]')\n      : s.replace(/[?*()[\\]\\\\{}]/g, '\\\\$&')\n  }\n  return windowsPathsNoEscape ?\n      s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import { expand } from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\nexport type Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  /** do not expand `{x,y}` style braces */\n  nobrace?: boolean\n  /** do not treat patterns starting with `#` as a comment */\n  nocomment?: boolean\n  /** do not treat patterns starting with `!` as a negation */\n  nonegate?: boolean\n  /** print LOTS of debugging output */\n  debug?: boolean\n  /** treat `**` the same as `*` */\n  noglobstar?: boolean\n  /** do not expand extglobs like `+(a|b)` */\n  noext?: boolean\n  /** return the pattern if nothing matches */\n  nonull?: boolean\n  /** treat `\\\\` as a path separator, not an escape character */\n  windowsPathsNoEscape?: boolean\n  /**\n   * inverse of {@link MinimatchOptions.windowsPathsNoEscape}\n   * @deprecated\n   */\n  allowWindowsEscape?: boolean\n  /**\n   * Compare a partial path to a pattern. As long as the parts\n   * of the path that are present are not contradicted by the\n   * pattern, it will be treated as a match. This is useful in\n   * applications where you're walking through a folder structure,\n   * and don't yet have the full path, but want to ensure that you\n   * do not walk down paths that can never be a match.\n   */\n  partial?: boolean\n  /** allow matches that start with `.` even if the pattern does not */\n  dot?: boolean\n  /** ignore case */\n  nocase?: boolean\n  /** ignore case only in wildcard patterns */\n  nocaseMagicOnly?: boolean\n  /** consider braces to be \"magic\" for the purpose of `hasMagic` */\n  magicalBraces?: boolean\n  /**\n   * If set, then patterns without slashes will be matched\n   * against the basename of the path if it contains slashes.\n   * For example, `a?b` would match the path `/xyz/123/acb`, but\n   * not `/xyz/acb/123`.\n   */\n  matchBase?: boolean\n  /** invert the results of negated matches */\n  flipNegate?: boolean\n  /** do not collapse multiple `/` into a single `/` */\n  preserveMultipleSlashes?: boolean\n  /**\n   * A number indicating the level of optimization that should be done\n   * to the pattern prior to parsing and using it for matches.\n   */\n  optimizationLevel?: number\n  /** operating system platform */\n  platform?: Platform\n  /**\n   * When a pattern starts with a UNC path or drive letter, and in\n   * `nocase:true` mode, do not convert the root portions of the\n   * pattern into a case-insensitive regular expression, and instead\n   * leave them as strings.\n   *\n   * This is the default when the platform is `win32` and\n   * `nocase:true` is set.\n   */\n  windowsNoMagicRoot?: boolean\n  /**\n   * max number of `{...}` patterns to expand. Default 100_000.\n   */\n  braceExpandMax?: number\n  /**\n   * Max number of non-adjacent `**` patterns to recursively walk down.\n   *\n   * The default of 200 is almost certainly high enough for most purposes,\n   * and can handle absurdly excessive patterns.\n   */\n  maxGlobstarRecursion?: number\n\n  /**\n   * Max depth to traverse for nested extglobs like `*(a|b|c)`\n   *\n   * Default is 2, which is quite low, but any higher value\n   * swiftly results in punishing performance impacts. Note\n   * that this is *not*  relevant when the globstar types can\n   * be safely coalesced into a single set.\n   *\n   * For example, `*(a|@(b|c)|d)` would be flattened into\n   * `*(a|b|c|d)`. Thus, many common extglobs will retain good\n   * performance and  never hit this limit, even if they are\n   * excessively deep and complicated.\n   *\n   * If the limit is hit, then the extglob characters are simply\n   * not parsed, and the pattern effectively switches into\n   * `noextglob: true` mode for the contents of that nested\n   * sub-pattern. This will typically _not_ result in a match,\n   * but is considered a valid trade-off for security and\n   * performance.\n   */\n  maxExtglobRecursion?: number\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {},\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) =>\n  !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) =>\n  f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) =>\n  f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process ?\n    (typeof process.env === 'object' &&\n      process.env &&\n      process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n    process.platform\n  : 'posix') as Platform\n\nexport type Sep = '\\\\' | '/'\n\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep =\n  defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {},\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<\n        MinimatchOptions,\n        'windowsPathsNoEscape' | 'magicalBraces'\n      > = {},\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<\n        MinimatchOptions,\n        'windowsPathsNoEscape' | 'magicalBraces'\n      > = {},\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) =>\n      orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (\n      list: string[],\n      pattern: string,\n      options: MinimatchOptions = {},\n    ) => orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {},\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern, { max: options.braceExpandMax })\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {},\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n  maxGlobstarRecursion: number\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.maxGlobstarRecursion = options.maxGlobstarRecursion ?? 200\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    // avoid the annoying deprecation flag lol\n    const awe = ('allowWindow' + 'sEscape') as keyof MinimatchOptions\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options[awe] === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined ?\n        options.windowsNoMagicRoot\n      : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [\n            ...s.slice(0, 4),\n            ...s.slice(4).map(ss => this.parse(ss)),\n          ]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1,\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes,\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false,\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(\n    file: string[],\n    pattern: ParseReturn[],\n    partial: boolean = false,\n  ) {\n    let fileStartIndex = 0\n    let patternStartIndex = 0\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive =\n        typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi =\n        fileUNC ? 3\n        : fileDrive ? 0\n        : undefined\n      const pdi =\n        patternUNC ? 3\n        : patternDrive ? 0\n        : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [\n          file[fdi],\n          pattern[pdi] as string,\n        ]\n        // start matching at the drive letter index of each\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          patternStartIndex = pdi\n          fileStartIndex = fdi\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // don't need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    if (pattern.includes(GLOBSTAR)) {\n      return this.#matchGlobstar(\n        file,\n        pattern,\n        partial,\n        fileStartIndex,\n        patternStartIndex,\n      )\n    }\n\n    return this.#matchOne(\n      file,\n      pattern,\n      partial,\n      fileStartIndex,\n      patternStartIndex,\n    )\n  }\n\n  #matchGlobstar(\n    file: string[],\n    pattern: ParseReturn[],\n    partial: boolean,\n    fileIndex: number,\n    patternIndex: number,\n  ) {\n    // split the pattern into head, tail, and middle of ** delimited parts\n    const firstgs = pattern.indexOf(GLOBSTAR, patternIndex)\n    const lastgs = pattern.lastIndexOf(GLOBSTAR)\n\n    // split the pattern up into globstar-delimited sections\n    // the tail has to be at the end, and the others just have\n    // to be found in order from the head.\n    const [head, body, tail] = partial ? [\n      pattern.slice(patternIndex, firstgs),\n      pattern.slice(firstgs + 1),\n      [],\n    ] : [\n      pattern.slice(patternIndex, firstgs),\n      pattern.slice(firstgs + 1, lastgs),\n      pattern.slice(lastgs + 1),\n    ]\n\n    // check the head, from the current file/pattern index.\n    if (head.length) {\n      const fileHead = file.slice(fileIndex, fileIndex + head.length)\n      if (!this.#matchOne(fileHead, head, partial, 0, 0)) {\n        return false\n      }\n      fileIndex += head.length\n      patternIndex += head.length\n    }\n    // now we know the head matches!\n\n    // if the last portion is not empty, it MUST match the end\n    // check the tail\n    let fileTailMatch: number = 0\n    if (tail.length) {\n      // if head + tail > file, then we cannot possibly match\n      if (tail.length + fileIndex > file.length) return false\n\n      // try to match the tail\n      let tailStart = file.length - tail.length\n      if (this.#matchOne(file, tail, partial, tailStart, 0)) {\n        fileTailMatch = tail.length\n      } else {\n        // affordance for stuff like a/**/* matching a/b/\n        // if the last file portion is '', and there's more to the pattern\n        // then try without the '' bit.\n        if (\n          file[file.length - 1] !== '' ||\n          fileIndex + tail.length === file.length\n        ) {\n          return false\n        }\n        tailStart--\n        if (!this.#matchOne(file, tail, partial, tailStart, 0)) {\n          return false\n        }\n        fileTailMatch = tail.length + 1\n      }\n    }\n\n    // now we know the tail matches!\n\n    // the middle is zero or more portions wrapped in **, possibly\n    // containing more ** sections.\n    // so a/**/b/**/c/**/d has become **/b/**/c/**\n    // if it's empty, it means a/**/b, just verify we have no bad dots\n    // if there's no tail, so it ends on /**, then we must have *something*\n    // after the head, or it's not a matc\n    if (!body.length) {\n      let sawSome = !!fileTailMatch\n      for (let i = fileIndex; i < file.length - fileTailMatch; i++) {\n        const f = String(file[i])\n        sawSome = true\n        if (\n          f === '.' ||\n          f === '..' ||\n          (!this.options.dot && f.startsWith('.'))\n        ) {\n          return false\n        }\n      }\n      // in partial mode, we just need to get past all file parts\n      return partial || sawSome\n    }\n\n    // now we know that there's one or more body sections, which can\n    // be matched anywhere from the 0 index (because the head was pruned)\n    // through to the length-fileTailMatch index.\n    // split the body up into sections, and note the minimum index it can\n    // be found at (start with the length of all previous segments)\n    // [section, before, after]\n    const bodySegments: [ParseReturn[], number][] = [[[], 0]]\n    let currentBody: [ParseReturn[], number] = bodySegments[0]\n    let nonGsParts = 0\n    const nonGsPartsSums: number[] = [0]\n    for (const b of body) {\n      if (b === GLOBSTAR) {\n        nonGsPartsSums.push(nonGsParts)\n        currentBody = [[], 0]\n        bodySegments.push(currentBody)\n      } else {\n        currentBody[0].push(b)\n        nonGsParts++\n      }\n    }\n    let i = bodySegments.length - 1\n    const fileLength = file.length - fileTailMatch\n    for (const b of bodySegments) {\n      b[1] = fileLength - ((nonGsPartsSums[i--] as number) + b[0].length)\n    }\n\n    return !!this.#matchGlobStarBodySections(\n      file,\n      bodySegments,\n      fileIndex,\n      0,\n      partial,\n      0,\n      !!fileTailMatch,\n    )\n  }\n\n  // return false for \"nope, not matching\"\n  // return null for \"not matching, cannot keep trying\"\n  #matchGlobStarBodySections(\n    file: string[],\n    // pattern section, last possible position for it\n    bodySegments: [ParseReturn[], number][],\n    fileIndex: number,\n    bodyIndex: number,\n    partial: boolean,\n    globStarDepth: number,\n    sawTail: boolean,\n  ): boolean | null {\n    // take the first body segment, and walk from fileIndex to its \"after\"\n    // value at the end\n    // If it doesn't match at that position, we increment, until we hit\n    // that final possible position, and give up.\n    // If it does match, then advance and try to rest.\n    // If any of them fail we keep walking forward.\n    // this is still a bit recursively painful, but it's more constrained\n    // than previous implementations, because we never test something that\n    // can't possibly be a valid matching condition.\n    const bs = bodySegments[bodyIndex]\n    if (!bs) {\n      // just make sure that there's no bad dots\n      for (let i = fileIndex; i < file.length; i++) {\n        sawTail = true\n        const f = file[i]\n        if (\n          f === '.' ||\n          f === '..' ||\n          (!this.options.dot && f.startsWith('.'))\n        ) {\n          return false\n        }\n      }\n      return sawTail\n    }\n\n    // have a non-globstar body section to test\n    const [body, after] = bs\n    while (fileIndex <= after) {\n      const m = this.#matchOne(\n        file.slice(0, fileIndex + body.length),\n        body,\n        partial,\n        fileIndex,\n        0,\n      )\n      // if limit exceeded, no match. intentional false negative,\n      // acceptable break in correctness for security.\n      if (m && globStarDepth < this.maxGlobstarRecursion) {\n        // match! see if the rest match. if so, we're done!\n        const sub = this.#matchGlobStarBodySections(\n          file,\n          bodySegments,\n          fileIndex + body.length,\n          bodyIndex + 1,\n          partial,\n          globStarDepth + 1,\n          sawTail,\n        )\n        if (sub !== false) {\n          return sub\n        }\n      }\n      const f = file[fileIndex]\n      if (\n        f === '.' ||\n        f === '..' ||\n        (!this.options.dot && f.startsWith('.'))\n      ) {\n        return false\n      }\n\n      fileIndex++\n    }\n    // walked off. no point continuing\n    return partial || null\n  }\n\n  #matchOne(\n    file: string[],\n    pattern: ParseReturn[],\n    partial: boolean,\n    fileIndex: number,\n    patternIndex: number,\n  ) {\n    let fi: number\n    let pi: number\n    let pl: number\n    let fl: number\n    for (\n      fi = fileIndex,\n        pi = patternIndex,\n        fl = file.length,\n        pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      let p = pattern[pi]\n      let f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false || p === GLOBSTAR) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase ?\n          options.dot ?\n            starDotExtTestNocaseDot\n          : starDotExtTestNocase\n        : options.dot ? starDotExtTestDot\n        : starDotExtTest)(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase ?\n          options.dot ?\n            qmarksTestNocaseDot\n          : qmarksTestNocase\n        : options.dot ? qmarksTestDot\n        : qmarksTest)(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar =\n      options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return (\n            typeof p === 'string' ? regExpEscape(p)\n            : p === GLOBSTAR ? GLOBSTAR\n            : p._src\n          )\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        const filtered = pp.filter(p => p !== GLOBSTAR)\n\n        // For partial matches, we need to make the pattern match\n        // any prefix of the full path. We do this by generating\n        // alternative patterns that match progressively longer prefixes.\n        if (this.partial && filtered.length >= 1) {\n          const prefixes: string[] = []\n          for (let i = 1; i <= filtered.length; i++) {\n            prefixes.push(filtered.slice(0, i).join('/'))\n          }\n          return '(?:' + prefixes.join('|') + ')'\n        }\n\n        return filtered.join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // In partial mode, '/' should always match as it's a valid prefix for any pattern\n    if (this.partial) {\n      re = '^(?:\\\\/|' + open + re.slice(1, -1) + close + ')$'\n    }\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "import * as path from \"node:path\";\nimport * as fs from \"node:fs/promises\";\nimport * as os from \"node:os\";\nimport * as vscode from \"vscode\";\nimport { minimatch } from \"minimatch\";\nimport type { SyncFileEntry } from \"./types.js\";\n\nexport interface SyncRoots {\n  cursorUser: string;\n  dotCursor: string;\n}\n\nconst DENYLIST_DIRS = [\n  \"extensions\",\n  \"logs\",\n  \"CachedData\",\n  \"CachedExtensions\",\n  \"CachedProfilesData\",\n  \"Crashpad\",\n  \"DawnCache\",\n  \"GPUCache\",\n  \"blob_storage\",\n  \"Local Storage\",\n  \"Session Storage\",\n  \"Network\",\n  \"shared_proto_db\",\n  \"databases\",\n];\n\nconst DENYLIST_FILES = [\"TransportSecurity\"];\n\nconst DENYLIST_GLOBS = [\"Cookies*\", \"*.db\", \"*.db-journal\", \"*.db-wal\", \"*.log\"];\n\nexport function resolveSyncRoots(\n  platform: NodeJS.Platform = process.platform\n): SyncRoots {\n  if (platform === \"win32\") {\n    const appData = process.env[\"APPDATA\"] || path.join(os.homedir(), \"AppData\", \"Roaming\");\n    const userProfile = process.env[\"USERPROFILE\"] || os.homedir();\n    return {\n      cursorUser: path.join(appData, \"Cursor\", \"User\"),\n      dotCursor: path.join(userProfile, \".cursor\"),\n    };\n  }\n\n  if (platform === \"darwin\") {\n    const home = os.homedir();\n    return {\n      cursorUser: path.join(home, \"Library\", \"Application Support\", \"Cursor\", \"User\"),\n      dotCursor: path.join(home, \".cursor\"),\n    };\n  }\n\n  const configHome = process.env[\"XDG_CONFIG_HOME\"] || path.join(os.homedir(), \".config\");\n  return {\n    cursorUser: path.join(configHome, \"Cursor\", \"User\"),\n    dotCursor: path.join(os.homedir(), \".cursor\"),\n  };\n}\n\nexport async function enumerateSyncFiles(\n  roots?: SyncRoots\n): Promise<SyncFileEntry[]> {\n  const resolved = roots ?? resolveSyncRoots();\n  const config = vscode.workspace.getConfiguration(\"cursorSync\");\n  const enabledPaths = config.get<string[]>(\"enabledPaths\") ?? getDefaultEnabledPaths();\n  const excludeGlobs = config.get<string[]>(\"excludeGlobs\") ?? [];\n  const maxFileSizeKB = config.get<number>(\"maxFileSizeKB\") ?? 512;\n  const maxBytes = maxFileSizeKB * 1024;\n\n  const cursorUserGlobs = enabledPaths.filter(\n    (g) =>\n      g === \"settings.json\" ||\n      g === \"keybindings.json\" ||\n      g === \"extensions.json\" ||\n      g.startsWith(\"snippets\")\n  );\n  const dotCursorGlobs = enabledPaths.filter(\n    (g) =>\n      g.startsWith(\"skills\") ||\n      g.startsWith(\"commands\") ||\n      g.startsWith(\"rules\")\n  );\n\n  const entries: SyncFileEntry[] = [];\n\n  await collectFiles(\n    resolved.cursorUser,\n    \"cursor-user\",\n    cursorUserGlobs,\n    excludeGlobs,\n    maxBytes,\n    entries\n  );\n  await collectFiles(\n    resolved.dotCursor,\n    \"dot-cursor\",\n    dotCursorGlobs,\n    excludeGlobs,\n    maxBytes,\n    entries\n  );\n\n  return entries.sort((a, b) => a.relativeSyncKey.localeCompare(b.relativeSyncKey));\n}\n\nasync function collectFiles(\n  rootDir: string,\n  prefix: string,\n  includeGlobs: string[],\n  excludeGlobs: string[],\n  maxBytes: number,\n  result: SyncFileEntry[]\n): Promise<void> {\n  const exists = await dirExists(rootDir);\n  if (!exists) {\n    return;\n  }\n\n  const allFiles = await walkDirectory(rootDir);\n  for (const absPath of allFiles) {\n    const rel = path.relative(rootDir, absPath).split(path.sep).join(\"/\");\n\n    if (isDenylisted(rel)) {\n      continue;\n    }\n\n    const matchesInclude = includeGlobs.some((g) => minimatch(rel, g));\n    if (!matchesInclude) {\n      continue;\n    }\n\n    const matchesExclude = excludeGlobs.some((g) => minimatch(rel, g));\n    if (matchesExclude) {\n      continue;\n    }\n\n    try {\n      const stat = await fs.stat(absPath);\n      if (stat.size > maxBytes) {\n        continue;\n      }\n    } catch {\n      continue;\n    }\n\n    result.push({\n      absolutePath: absPath,\n      relativeSyncKey: `${prefix}/${rel}`,\n    });\n  }\n}\n\nfunction isDenylisted(relativePath: string): boolean {\n  const parts = relativePath.split(\"/\");\n  const topDir = parts[0];\n\n  if (topDir && DENYLIST_DIRS.includes(topDir)) {\n    return true;\n  }\n\n  const fileName = parts[parts.length - 1];\n  if (fileName && DENYLIST_FILES.includes(fileName)) {\n    return true;\n  }\n\n  if (fileName) {\n    for (const glob of DENYLIST_GLOBS) {\n      if (minimatch(fileName, glob)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nasync function walkDirectory(dir: string): Promise<string[]> {\n  const results: string[] = [];\n  let entries: import(\"node:fs\").Dirent[];\n  try {\n    entries = await fs.readdir(dir, { withFileTypes: true });\n  } catch {\n    return results;\n  }\n  for (const entry of entries) {\n    const fullPath = path.join(dir, entry.name);\n    if (entry.isDirectory()) {\n      const sub = await walkDirectory(fullPath);\n      results.push(...sub);\n    } else if (entry.isFile()) {\n      results.push(fullPath);\n    }\n  }\n  return results;\n}\n\nasync function dirExists(p: string): Promise<boolean> {\n  try {\n    const stat = await fs.stat(p);\n    return stat.isDirectory();\n  } catch {\n    return false;\n  }\n}\n\nexport function getDefaultEnabledPaths(): string[] {\n  return [\n    \"settings.json\",\n    \"keybindings.json\",\n    \"snippets/**\",\n    \"extensions.json\",\n    \"skills/**/SKILL.md\",\n    \"skills-cursor/**/SKILL.md\",\n    \"commands/**/*.md\",\n    \"rules/*.mdc\",\n  ];\n}\n\nexport function syncKeyToGistFileName(syncKey: string): string {\n  return syncKey.replace(/\\//g, \"--\");\n}\n\nexport function gistFileNameToSyncKey(gistFileName: string): string {\n  return gistFileName.replace(/--/g, \"/\");\n}\n", "import * as vscode from \"vscode\";\nimport { configureGithub, getToken } from \"./auth.js\";\nimport { executePush } from \"./push.js\";\nimport { executePull } from \"./pull.js\";\nimport { showStatus } from \"./diagnostics.js\";\nimport { resolveConflictsCommand } from \"./conflicts.js\";\nimport { startScheduler, stopScheduler } from \"./scheduler.js\";\nimport { getLogger } from \"./diagnostics.js\";\n\nlet configListener: vscode.Disposable | undefined;\n\nexport function activate(context: vscode.ExtensionContext): void {\n  const logger = getLogger();\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"cursorSync.configureGithub\", () =>\n      configureGithub(context)\n    )\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"cursorSync.push\", () =>\n      executePush(context)\n    )\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"cursorSync.pull\", () =>\n      executePull(context)\n    )\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"cursorSync.showStatus\", () =>\n      showStatus(context)\n    )\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"cursorSync.resolveConflicts\", () =>\n      resolveConflictsCommand(context)\n    )\n  );\n\n  updateConfiguredContext(context);\n  startScheduler(context);\n\n  configListener = vscode.workspace.onDidChangeConfiguration((e) => {\n    if (e.affectsConfiguration(\"cursorSync.schedule\")) {\n      stopScheduler();\n      startScheduler(context);\n    }\n  });\n  context.subscriptions.push(configListener);\n\n  logger.appendLine(`[${new Date().toISOString()}] Cursor Sync activated`);\n}\n\nexport function deactivate(): void {\n  stopScheduler();\n}\n\nasync function updateConfiguredContext(\n  context: vscode.ExtensionContext\n): Promise<void> {\n  const token = await getToken(context);\n  await vscode.commands.executeCommand(\n    \"setContext\",\n    \"cursorSync.configured\",\n    token !== undefined\n  );\n}\n", "import * as vscode from \"vscode\";\nimport { GistClient } from \"./gist.js\";\nimport { withRetry } from \"./retry.js\";\nimport { getLogger } from \"./diagnostics.js\";\n\nconst SECRET_KEY = \"cursorSync.githubPAT\";\n\nexport async function configureGithub(\n  context: vscode.ExtensionContext\n): Promise<void> {\n  const logger = getLogger();\n\n  const pat = await vscode.window.showInputBox({\n    prompt: \"Enter your GitHub Personal Access Token (requires gist scope)\",\n    password: true,\n    ignoreFocusOut: true,\n    placeHolder: \"ghp_xxxxxxxxxxxx\",\n    validateInput: (value) => {\n      if (!value || value.trim().length === 0) {\n        return \"Token cannot be empty\";\n      }\n      return undefined;\n    },\n  });\n\n  if (!pat) {\n    return;\n  }\n\n  const client = new GistClient(pat.trim());\n  const result = await withRetry(() => client.validateToken());\n\n  if (!result.ok) {\n    logger.appendLine(\n      `[${new Date().toISOString()}] Token validation failed: ${result.error.message}`\n    );\n    vscode.window.showErrorMessage(\n      `GitHub token validation failed: ${result.error.message}`\n    );\n    return;\n  }\n\n  await context.secrets.store(SECRET_KEY, pat.trim());\n  await vscode.commands.executeCommand(\"setContext\", \"cursorSync.configured\", true);\n  vscode.window.showInformationMessage(\"GitHub token configured successfully.\");\n  logger.appendLine(`[${new Date().toISOString()}] GitHub token configured`);\n}\n\nexport async function getToken(\n  context: vscode.ExtensionContext\n): Promise<string | undefined> {\n  return context.secrets.get(SECRET_KEY);\n}\n\nexport async function requireToken(\n  context: vscode.ExtensionContext\n): Promise<string | undefined> {\n  const token = await getToken(context);\n  if (!token) {\n    const action = await vscode.window.showWarningMessage(\n      \"GitHub token not configured. Configure now?\",\n      \"Configure\"\n    );\n    if (action === \"Configure\") {\n      await configureGithub(context);\n      return getToken(context);\n    }\n    return undefined;\n  }\n  return token;\n}\n\nexport async function validateStoredToken(\n  context: vscode.ExtensionContext\n): Promise<boolean> {\n  const token = await getToken(context);\n  if (!token) {\n    return false;\n  }\n\n  const client = new GistClient(token);\n  const result = await withRetry(() => client.validateToken());\n\n  if (!result.ok) {\n    vscode.window.showErrorMessage(\n      \"Stored GitHub token is no longer valid. Please reconfigure.\"\n    );\n    await vscode.commands.executeCommand(\"setContext\", \"cursorSync.configured\", false);\n    return false;\n  }\n\n  return true;\n}\n", "import type { ApiResult, GistResponse, FailureCategory } from \"./types.js\";\n\nconst GITHUB_API = \"https://api.github.com\";\nconst USER_AGENT = \"cursor-sync-extension\";\n\nexport class GistClient {\n  private pat: string;\n\n  constructor(pat: string) {\n    this.pat = pat;\n  }\n\n  async validateToken(): Promise<ApiResult<boolean>> {\n    return this.request<boolean>(\"GET\", \"/gists?per_page=1\", undefined, () => true);\n  }\n\n  async getGist(gistId: string): Promise<ApiResult<GistResponse>> {\n    return this.request<GistResponse>(\"GET\", `/gists/${gistId}`);\n  }\n\n  async createGist(\n    files: Record<string, { content: string }>,\n    description: string\n  ): Promise<ApiResult<GistResponse>> {\n    return this.request<GistResponse>(\"POST\", \"/gists\", {\n      description,\n      public: false,\n      files,\n    });\n  }\n\n  async updateGist(\n    gistId: string,\n    files: Record<string, { content: string } | null>\n  ): Promise<ApiResult<GistResponse>> {\n    return this.request<GistResponse>(\"PATCH\", `/gists/${gistId}`, { files });\n  }\n\n  private async request<T>(\n    method: string,\n    endpoint: string,\n    body?: unknown,\n    transform?: (data: unknown) => T\n  ): Promise<ApiResult<T>> {\n    const url = `${GITHUB_API}${endpoint}`;\n    const headers: Record<string, string> = {\n      Authorization: `token ${this.pat}`,\n      Accept: \"application/vnd.github.v3+json\",\n      \"User-Agent\": USER_AGENT,\n    };\n\n    if (body) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        method,\n        headers,\n        body: body ? JSON.stringify(body) : undefined,\n      });\n    } catch (err) {\n      return {\n        ok: false,\n        error: {\n          category: \"NETWORK_ERROR\",\n          message: err instanceof Error ? err.message : \"Network request failed\",\n        },\n      };\n    }\n\n    const rateLimitRemaining = response.headers.get(\"X-RateLimit-Remaining\");\n    const retryAfterHeader = response.headers.get(\"Retry-After\");\n\n    if (response.status === 429) {\n      return {\n        ok: false,\n        error: {\n          category: \"RATE_LIMITED\",\n          message: \"GitHub API rate limit exceeded\",\n          statusCode: 429,\n          retryAfter: retryAfterHeader ? parseInt(retryAfterHeader, 10) : 60,\n        },\n      };\n    }\n\n    if (response.status === 401 || response.status === 403) {\n      return {\n        ok: false,\n        error: {\n          category: \"AUTH_FAILED\",\n          message: `Authentication failed (${response.status})`,\n          statusCode: response.status,\n        },\n      };\n    }\n\n    if (response.status >= 500) {\n      return {\n        ok: false,\n        error: {\n          category: \"NETWORK_ERROR\",\n          message: `Server error (${response.status})`,\n          statusCode: response.status,\n        },\n      };\n    }\n\n    if (!response.ok) {\n      let errorMessage = `GitHub API error (${response.status})`;\n      try {\n        const errorBody = (await response.json()) as { message?: string };\n        if (errorBody.message) {\n          errorMessage = errorBody.message;\n        }\n      } catch {}\n      return {\n        ok: false,\n        error: {\n          category: \"UNKNOWN\" as FailureCategory,\n          message: errorMessage,\n          statusCode: response.status,\n        },\n      };\n    }\n\n    try {\n      const data = await response.json();\n      const result = transform ? transform(data) : (data as T);\n      return { ok: true, data: result };\n    } catch (err) {\n      return {\n        ok: false,\n        error: {\n          category: \"UNKNOWN\",\n          message: \"Failed to parse response JSON\",\n        },\n      };\n    }\n  }\n}\n", "import type { ApiResult, ApiError, FailureCategory } from \"./types.js\";\n\nconst MAX_ATTEMPTS = 3;\nconst BACKOFF_BASE_MS = 1000;\nconst BACKOFF_MULTIPLIER = 3;\n\nconst NON_RETRYABLE_CODES = new Set([401, 403, 404, 422]);\n\nexport async function withRetry<T>(\n  fn: () => Promise<ApiResult<T>>\n): Promise<ApiResult<T>> {\n  let lastError: ApiError | undefined;\n\n  for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {\n    const result = await fn();\n\n    if (result.ok) {\n      return result;\n    }\n\n    lastError = result.error;\n\n    if (result.error.statusCode && NON_RETRYABLE_CODES.has(result.error.statusCode)) {\n      return result;\n    }\n\n    if (attempt < MAX_ATTEMPTS - 1) {\n      const delay = result.error.retryAfter\n        ? result.error.retryAfter * 1000\n        : BACKOFF_BASE_MS * Math.pow(BACKOFF_MULTIPLIER, attempt);\n      await sleep(delay);\n    }\n  }\n\n  return {\n    ok: false,\n    error: lastError ?? {\n      category: \"UNKNOWN\" as FailureCategory,\n      message: \"All retry attempts exhausted\",\n    },\n  };\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "import * as vscode from \"vscode\";\nimport * as fs from \"node:fs/promises\";\nimport * as path from \"node:path\";\nimport type { SyncState } from \"./types.js\";\n\nlet outputChannel: vscode.OutputChannel | undefined;\n\nexport function getLogger(): vscode.OutputChannel {\n  if (!outputChannel) {\n    outputChannel = vscode.window.createOutputChannel(\"Cursor Sync\");\n  }\n  return outputChannel;\n}\n\nexport async function showStatus(\n  context: vscode.ExtensionContext\n): Promise<void> {\n  const syncState = await loadSyncState(context);\n  const items: vscode.QuickPickItem[] = [];\n\n  if (!syncState) {\n    items.push({ label: \"Status\", description: \"No sync performed yet\" });\n    vscode.window.showQuickPick(items, { title: \"Cursor Sync Status\" });\n    return;\n  }\n\n  items.push({\n    label: \"Last Sync\",\n    description: syncState.lastSyncTimestamp,\n  });\n  items.push({\n    label: \"Direction\",\n    description: syncState.lastSyncDirection,\n  });\n  items.push({\n    label: \"Gist ID\",\n    description: syncState.gistId,\n  });\n  items.push({\n    label: \"Gist URL\",\n    description: `https://gist.github.com/${syncState.gistId}`,\n  });\n  items.push({\n    label: \"Files Synced\",\n    description: String(Object.keys(syncState.localChecksums).length),\n  });\n\n  vscode.window.showQuickPick(items, { title: \"Cursor Sync Status\" });\n}\n\nexport function getSyncStatePath(context: vscode.ExtensionContext): string {\n  return path.join(\n    context.globalStorageUri.fsPath,\n    \"sync-state.json\"\n  );\n}\n\nexport async function loadSyncState(\n  context: vscode.ExtensionContext\n): Promise<SyncState | undefined> {\n  const filePath = getSyncStatePath(context);\n  try {\n    const data = await fs.readFile(filePath, \"utf-8\");\n    return JSON.parse(data) as SyncState;\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function saveSyncState(\n  context: vscode.ExtensionContext,\n  state: SyncState\n): Promise<void> {\n  const filePath = getSyncStatePath(context);\n  const dir = path.dirname(filePath);\n  await fs.mkdir(dir, { recursive: true });\n  await fs.writeFile(filePath, JSON.stringify(state, null, 2), \"utf-8\");\n}\n", "import * as vscode from \"vscode\";\nimport * as fs from \"node:fs/promises\";\nimport { enumerateSyncFiles, syncKeyToGistFileName } from \"./paths.js\";\nimport { packageFiles, computeChecksum } from \"./packaging.js\";\nimport { GistClient } from \"./gist.js\";\nimport { requireToken, validateStoredToken } from \"./auth.js\";\nimport { withRetry } from \"./retry.js\";\nimport { loadSyncState, saveSyncState, getLogger } from \"./diagnostics.js\";\nimport { detectConflicts, clearConflicts, getPendingConflicts, getResolutionForKey } from \"./conflicts.js\";\nimport { generateExtensionsJson } from \"./extensions.js\";\nimport type { SyncState } from \"./types.js\";\n\nlet pushLock = false;\n\nexport function isPushLocked(): boolean {\n  return pushLock;\n}\n\nexport async function executePush(\n  context: vscode.ExtensionContext\n): Promise<boolean> {\n  const logger = getLogger();\n\n  if (pushLock) {\n    vscode.window.showWarningMessage(\"A sync operation is already in progress.\");\n    return false;\n  }\n\n  pushLock = true;\n  try {\n    return await doPush(context);\n  } finally {\n    pushLock = false;\n  }\n}\n\nasync function doPush(context: vscode.ExtensionContext): Promise<boolean> {\n  const logger = getLogger();\n  logger.appendLine(`[${new Date().toISOString()}] Push started`);\n\n  if (!(await validateStoredToken(context))) {\n    const token = await requireToken(context);\n    if (!token) {\n      logger.appendLine(`[${new Date().toISOString()}] Push failed: AUTH_FAILED`);\n      return false;\n    }\n  }\n\n  const token = await requireToken(context);\n  if (!token) {\n    return false;\n  }\n\n  const client = new GistClient(token);\n  const syncState = await loadSyncState(context);\n\n  if (syncState) {\n    const remoteChecksums = syncState.remoteChecksums;\n    const conflicts = await detectConflicts(context, remoteChecksums);\n    if (conflicts.length > 0) {\n      const unresolved = conflicts.filter((c) => {\n        const resolution = getResolutionForKey(c.relativeSyncKey);\n        return !resolution || resolution === \"skip\";\n      });\n      if (unresolved.length > 0) {\n        vscode.window.showWarningMessage(\n          `${unresolved.length} conflict(s) detected. Resolve them before pushing.`\n        );\n        logger.appendLine(`[${new Date().toISOString()}] Push blocked: CONFLICT`);\n        return false;\n      }\n    }\n  }\n\n  const extensionsJson = generateExtensionsJson();\n  const cursorUserRoot = (await import(\"./paths.js\")).resolveSyncRoots().cursorUser;\n  const extensionsPath = await writeExtensionsFile(cursorUserRoot, extensionsJson);\n\n  const files = await enumerateSyncFiles();\n  const config = vscode.workspace.getConfiguration(\"cursorSync\");\n  const profileName = config.get<string>(\"syncProfileName\") ?? \"default\";\n  const { packaged, manifest } = await packageFiles(files, profileName);\n\n  const gistFiles: Record<string, { content: string }> = {};\n  gistFiles[\"manifest.json\"] = { content: JSON.stringify(manifest, null, 2) };\n\n  for (const [key, value] of packaged) {\n    const gistFileName = syncKeyToGistFileName(key);\n    gistFiles[gistFileName] = { content: value.content };\n  }\n\n  let gistId = syncState?.gistId;\n\n  if (!gistId) {\n    const result = await withRetry(() =>\n      client.createGist(gistFiles, \"Cursor Sync - Settings Backup\")\n    );\n    if (!result.ok) {\n      vscode.window.showErrorMessage(`Push failed: ${result.error.message}`);\n      logger.appendLine(\n        `[${new Date().toISOString()}] Push failed: ${result.error.category} - ${result.error.message}`\n      );\n      return false;\n    }\n    gistId = result.data.id;\n  } else {\n    const existingResult = await withRetry(() => client.getGist(gistId!));\n    let filesToDelete: Record<string, null> = {};\n    if (existingResult.ok) {\n      const existingFiles = Object.keys(existingResult.data.files);\n      for (const existing of existingFiles) {\n        if (existing !== \"manifest.json\" && !gistFiles[existing]) {\n          filesToDelete[existing] = null;\n        }\n      }\n    }\n\n    const updatePayload: Record<string, { content: string } | null> = {\n      ...gistFiles,\n      ...filesToDelete,\n    };\n\n    const result = await withRetry(() =>\n      client.updateGist(gistId!, updatePayload)\n    );\n    if (!result.ok) {\n      vscode.window.showErrorMessage(`Push failed: ${result.error.message}`);\n      logger.appendLine(\n        `[${new Date().toISOString()}] Push failed: ${result.error.category} - ${result.error.message}`\n      );\n      return false;\n    }\n  }\n\n  const checksums: Record<string, string> = {};\n  for (const [key, value] of packaged) {\n    checksums[key] = value.checksum;\n  }\n\n  const newState: SyncState = {\n    lastSyncTimestamp: new Date().toISOString(),\n    lastSyncDirection: \"push\",\n    gistId: gistId!,\n    localChecksums: checksums,\n    remoteChecksums: checksums,\n  };\n  await saveSyncState(context, newState);\n  clearConflicts();\n\n  const fileCount = packaged.size;\n  vscode.window.showInformationMessage(\n    `Push complete: ${fileCount} file(s) synced.`\n  );\n  logger.appendLine(\n    `[${new Date().toISOString()}] Push succeeded: ${fileCount} files`\n  );\n  return true;\n}\n\nasync function writeExtensionsFile(\n  cursorUserRoot: string,\n  content: string\n): Promise<string> {\n  const filePath = (await import(\"node:path\")).join(\n    cursorUserRoot,\n    \"extensions.json\"\n  );\n  const dir = (await import(\"node:path\")).dirname(filePath);\n  await fs.mkdir(dir, { recursive: true });\n  await fs.writeFile(filePath, content, \"utf-8\");\n  return filePath;\n}\n", "import * as crypto from \"node:crypto\";\nimport * as fs from \"node:fs/promises\";\nimport * as os from \"node:os\";\nimport type { SyncFileEntry, PackagedFile, Manifest, ManifestFileEntry } from \"./types.js\";\n\nexport async function packageFiles(\n  files: SyncFileEntry[],\n  profileName: string\n): Promise<{ packaged: Map<string, PackagedFile>; manifest: Manifest }> {\n  const sorted = [...files].sort((a, b) =>\n    a.relativeSyncKey.localeCompare(b.relativeSyncKey)\n  );\n\n  const packaged = new Map<string, PackagedFile>();\n  const manifestFiles: Record<string, ManifestFileEntry> = {};\n\n  for (const file of sorted) {\n    const buf = await fs.readFile(file.absolutePath);\n    const isUtf8 = isValidUtf8(buf);\n\n    const content = isUtf8 ? buf.toString(\"utf-8\") : buf.toString(\"base64\");\n    const checksum = crypto.createHash(\"sha256\").update(buf).digest(\"hex\");\n    const sizeBytes = buf.length;\n\n    const entry: PackagedFile = { content, checksum, sizeBytes };\n    const manifestEntry: ManifestFileEntry = { checksum, sizeBytes };\n\n    if (!isUtf8) {\n      entry.encoding = \"base64\";\n      manifestEntry.encoding = \"base64\";\n    }\n\n    packaged.set(file.relativeSyncKey, entry);\n    manifestFiles[file.relativeSyncKey] = manifestEntry;\n  }\n\n  const manifest: Manifest = {\n    schemaVersion: 1,\n    syncProfileName: profileName,\n    createdAt: new Date().toISOString(),\n    sourceMachineId: computeMachineId(),\n    sourceOS: process.platform as Manifest[\"sourceOS\"],\n    files: manifestFiles,\n  };\n\n  return { packaged, manifest };\n}\n\nexport function computeChecksum(content: Buffer): string {\n  return crypto.createHash(\"sha256\").update(content).digest(\"hex\");\n}\n\nexport function computeMachineId(): string {\n  const raw = `${os.hostname()}:${os.userInfo().username}`;\n  return crypto.createHash(\"sha256\").update(raw).digest(\"hex\");\n}\n\nfunction isValidUtf8(buf: Buffer): boolean {\n  try {\n    const decoded = new TextDecoder(\"utf-8\", { fatal: true }).decode(buf);\n    return decoded !== undefined;\n  } catch {\n    return false;\n  }\n}\n", "import * as vscode from \"vscode\";\nimport * as fs from \"node:fs/promises\";\nimport type {\n  SyncState,\n  ConflictEntry,\n  ResolvedConflict,\n  ConflictResolution,\n} from \"./types.js\";\nimport { computeChecksum } from \"./packaging.js\";\nimport { enumerateSyncFiles } from \"./paths.js\";\nimport { loadSyncState } from \"./diagnostics.js\";\nimport { getLogger } from \"./diagnostics.js\";\n\nlet pendingResolutions: ResolvedConflict[] = [];\nlet pendingConflicts: ConflictEntry[] = [];\n\nexport function getPendingConflicts(): ConflictEntry[] {\n  return pendingConflicts;\n}\n\nexport function getPendingResolutions(): ResolvedConflict[] {\n  return pendingResolutions;\n}\n\nexport function clearConflicts(): void {\n  pendingConflicts = [];\n  pendingResolutions = [];\n  vscode.commands.executeCommand(\"setContext\", \"cursorSync.hasConflicts\", false);\n}\n\nexport async function detectConflicts(\n  context: vscode.ExtensionContext,\n  remoteChecksums: Record<string, string>\n): Promise<ConflictEntry[]> {\n  const syncState = await loadSyncState(context);\n  if (!syncState) {\n    return [];\n  }\n\n  const localFiles = await enumerateSyncFiles();\n  const localChecksums: Record<string, string> = {};\n\n  for (const file of localFiles) {\n    try {\n      const buf = await fs.readFile(file.absolutePath);\n      localChecksums[file.relativeSyncKey] = computeChecksum(buf);\n    } catch {\n      continue;\n    }\n  }\n\n  const conflicts: ConflictEntry[] = [];\n  const allKeys = new Set([\n    ...Object.keys(localChecksums),\n    ...Object.keys(remoteChecksums),\n  ]);\n\n  for (const key of allKeys) {\n    const baseLocal = syncState.localChecksums[key];\n    const baseRemote = syncState.remoteChecksums[key];\n    const currentLocal = localChecksums[key];\n    const currentRemote = remoteChecksums[key];\n\n    if (!baseLocal || !baseRemote) {\n      continue;\n    }\n\n    const localChanged = currentLocal !== baseLocal;\n    const remoteChanged = currentRemote !== baseRemote;\n\n    if (localChanged && remoteChanged && currentLocal !== currentRemote) {\n      conflicts.push({\n        relativeSyncKey: key,\n        localChecksum: currentLocal ?? \"\",\n        remoteChecksum: currentRemote ?? \"\",\n        baseChecksum: baseLocal,\n      });\n    }\n  }\n\n  if (conflicts.length > 0) {\n    pendingConflicts = conflicts;\n    await vscode.commands.executeCommand(\n      \"setContext\",\n      \"cursorSync.hasConflicts\",\n      true\n    );\n  }\n\n  return conflicts;\n}\n\nexport async function resolveConflictsCommand(\n  context: vscode.ExtensionContext\n): Promise<void> {\n  const logger = getLogger();\n\n  if (pendingConflicts.length === 0) {\n    vscode.window.showInformationMessage(\"No conflicts to resolve.\");\n    return;\n  }\n\n  const resolutions: ResolvedConflict[] = [];\n\n  for (const conflict of pendingConflicts) {\n    const choice = await vscode.window.showQuickPick(\n      [\n        { label: \"Keep Local\", value: \"keepLocal\" as ConflictResolution },\n        { label: \"Keep Remote\", value: \"keepRemote\" as ConflictResolution },\n        { label: \"Skip (decide later)\", value: \"skip\" as ConflictResolution },\n      ],\n      {\n        title: `Conflict: ${conflict.relativeSyncKey}`,\n        placeHolder: \"Choose which version to keep\",\n      }\n    );\n\n    if (!choice) {\n      return;\n    }\n\n    resolutions.push({\n      relativeSyncKey: conflict.relativeSyncKey,\n      resolution: choice.value,\n    });\n  }\n\n  pendingResolutions = resolutions;\n\n  const hasSkipped = resolutions.some((r) => r.resolution === \"skip\");\n  if (!hasSkipped) {\n    pendingConflicts = [];\n    await vscode.commands.executeCommand(\n      \"setContext\",\n      \"cursorSync.hasConflicts\",\n      false\n    );\n  }\n\n  logger.appendLine(\n    `[${new Date().toISOString()}] Conflicts resolved: ${resolutions.length} decisions`\n  );\n  vscode.window.showInformationMessage(\n    `Resolved ${resolutions.length} conflict(s). You can now push or pull.`\n  );\n}\n\nexport function getResolutionForKey(\n  key: string\n): ConflictResolution | undefined {\n  const entry = pendingResolutions.find((r) => r.relativeSyncKey === key);\n  return entry?.resolution;\n}\n", "import * as vscode from \"vscode\";\n\ninterface ExtensionEntry {\n  id: string;\n  version: string;\n}\n\nexport function generateExtensionsJson(): string {\n  const extensions = vscode.extensions.all;\n  const entries: ExtensionEntry[] = [];\n\n  for (const ext of extensions) {\n    if (ext.id.startsWith(\"vscode.\")) {\n      continue;\n    }\n\n    const kind = ext.extensionKind;\n    if (kind === vscode.ExtensionKind.UI) {\n      // ExtensionKind.UI = 1, not builtin\n    }\n\n    entries.push({\n      id: ext.id,\n      version: ext.packageJSON?.version ?? \"0.0.0\",\n    });\n  }\n\n  entries.sort((a, b) => a.id.localeCompare(b.id));\n  return JSON.stringify(entries, null, 2);\n}\n\nexport function findMissingExtensions(\n  remoteEntries: ExtensionEntry[]\n): ExtensionEntry[] {\n  const installedIds = new Set(\n    vscode.extensions.all\n      .filter((ext) => !ext.id.startsWith(\"vscode.\"))\n      .map((ext) => ext.id.toLowerCase())\n  );\n\n  return remoteEntries.filter(\n    (entry) => !installedIds.has(entry.id.toLowerCase())\n  );\n}\n", "import * as vscode from \"vscode\";\nimport * as fs from \"node:fs/promises\";\nimport * as path from \"node:path\";\nimport { GistClient } from \"./gist.js\";\nimport { requireToken } from \"./auth.js\";\nimport { withRetry } from \"./retry.js\";\nimport { loadSyncState, saveSyncState, getLogger } from \"./diagnostics.js\";\nimport { resolveSyncRoots, gistFileNameToSyncKey } from \"./paths.js\";\nimport { computeChecksum } from \"./packaging.js\";\nimport { detectConflicts, clearConflicts, getResolutionForKey, getPendingConflicts } from \"./conflicts.js\";\nimport { createBackup, rollbackFromBackup, pruneOldBackups } from \"./rollback.js\";\nimport { findMissingExtensions } from \"./extensions.js\";\nimport type { SyncState, Manifest } from \"./types.js\";\n\nlet pullLock = false;\n\nexport async function executePull(\n  context: vscode.ExtensionContext\n): Promise<boolean> {\n  const logger = getLogger();\n\n  if (pullLock) {\n    vscode.window.showWarningMessage(\"A sync operation is already in progress.\");\n    return false;\n  }\n\n  pullLock = true;\n  try {\n    return await doPull(context);\n  } finally {\n    pullLock = false;\n  }\n}\n\nasync function doPull(context: vscode.ExtensionContext): Promise<boolean> {\n  const logger = getLogger();\n  logger.appendLine(`[${new Date().toISOString()}] Pull started`);\n\n  const syncState = await loadSyncState(context);\n  if (!syncState?.gistId) {\n    vscode.window.showErrorMessage(\n      \"Not configured. Push first or configure a Gist ID.\"\n    );\n    logger.appendLine(`[${new Date().toISOString()}] Pull failed: not configured`);\n    return false;\n  }\n\n  const token = await requireToken(context);\n  if (!token) {\n    return false;\n  }\n\n  const client = new GistClient(token);\n  const gistResult = await withRetry(() => client.getGist(syncState.gistId));\n\n  if (!gistResult.ok) {\n    vscode.window.showErrorMessage(`Pull failed: ${gistResult.error.message}`);\n    logger.appendLine(\n      `[${new Date().toISOString()}] Pull failed: ${gistResult.error.category} - ${gistResult.error.message}`\n    );\n    return false;\n  }\n\n  const gistData = gistResult.data;\n  const manifestFile = gistData.files[\"manifest.json\"];\n  if (!manifestFile) {\n    vscode.window.showErrorMessage(\"Pull failed: manifest.json not found in Gist.\");\n    logger.appendLine(`[${new Date().toISOString()}] Pull failed: missing manifest`);\n    return false;\n  }\n\n  let manifest: Manifest;\n  try {\n    manifest = JSON.parse(manifestFile.content) as Manifest;\n  } catch {\n    vscode.window.showErrorMessage(\"Pull failed: invalid manifest.json.\");\n    logger.appendLine(`[${new Date().toISOString()}] Pull failed: invalid manifest`);\n    return false;\n  }\n\n  const remoteChecksums: Record<string, string> = {};\n  for (const [key, entry] of Object.entries(manifest.files)) {\n    remoteChecksums[key] = entry.checksum;\n  }\n\n  const conflicts = await detectConflicts(context, remoteChecksums);\n  if (conflicts.length > 0) {\n    const unresolved = conflicts.filter((c) => {\n      const resolution = getResolutionForKey(c.relativeSyncKey);\n      return !resolution || resolution === \"skip\";\n    });\n    if (unresolved.length > 0) {\n      vscode.window.showWarningMessage(\n        `${unresolved.length} conflict(s) detected. Resolve them before pulling.`\n      );\n      logger.appendLine(`[${new Date().toISOString()}] Pull blocked: CONFLICT`);\n      return false;\n    }\n  }\n\n  const roots = resolveSyncRoots();\n  const filesToWrite: Array<{ absolutePath: string; syncKey: string; content: Buffer }> = [];\n\n  for (const [gistFileName, gistFile] of Object.entries(gistData.files)) {\n    if (gistFileName === \"manifest.json\") {\n      continue;\n    }\n\n    const syncKey = gistFileNameToSyncKey(gistFileName);\n    const manifestEntry = manifest.files[syncKey];\n    if (!manifestEntry) {\n      continue;\n    }\n\n    if (conflicts.length > 0) {\n      const resolution = getResolutionForKey(syncKey);\n      if (resolution === \"keepLocal\") {\n        continue;\n      }\n    }\n\n    const absolutePath = syncKeyToAbsolutePath(syncKey, roots);\n    if (!absolutePath) {\n      continue;\n    }\n\n    const content =\n      manifestEntry.encoding === \"base64\"\n        ? Buffer.from(gistFile.content, \"base64\")\n        : Buffer.from(gistFile.content, \"utf-8\");\n\n    filesToWrite.push({ absolutePath, syncKey, content });\n  }\n\n  const config = vscode.workspace.getConfiguration(\"cursorSync\");\n  const safeMode = config.get<boolean>(\"safeMode\") ?? true;\n\n  if (safeMode && filesToWrite.length > 0) {\n    const items = filesToWrite.map((f) => ({\n      label: f.syncKey,\n      picked: true,\n    }));\n    const selected = await vscode.window.showQuickPick(items, {\n      canPickMany: true,\n      title: \"Files to overwrite\",\n      placeHolder: \"Deselect files you do not want to overwrite\",\n    });\n\n    if (!selected) {\n      logger.appendLine(`[${new Date().toISOString()}] Pull cancelled by user`);\n      return false;\n    }\n\n    const selectedKeys = new Set(selected.map((s) => s.label));\n    const filtered = filesToWrite.filter((f) => selectedKeys.has(f.syncKey));\n    filesToWrite.length = 0;\n    filesToWrite.push(...filtered);\n  }\n\n  if (filesToWrite.length === 0) {\n    vscode.window.showInformationMessage(\"Pull complete: no files to update.\");\n    return true;\n  }\n\n  const { entries: backupEntries } = await createBackup(\n    context,\n    filesToWrite.map((f) => f.absolutePath)\n  );\n\n  const writtenBackups: typeof backupEntries = [];\n  let writeError = false;\n\n  for (const file of filesToWrite) {\n    try {\n      const dir = path.dirname(file.absolutePath);\n      await fs.mkdir(dir, { recursive: true });\n      const tmpPath = file.absolutePath + \".tmp\";\n      await fs.writeFile(tmpPath, file.content);\n      await fs.rename(tmpPath, file.absolutePath);\n      const backup = backupEntries.find((b) => b.absolutePath === file.absolutePath);\n      if (backup) {\n        writtenBackups.push(backup);\n      }\n    } catch (err) {\n      logger.appendLine(\n        `[${new Date().toISOString()}] Write failed for ${file.absolutePath}: ${err instanceof Error ? err.message : String(err)}`\n      );\n      writeError = true;\n      break;\n    }\n  }\n\n  if (writeError) {\n    logger.appendLine(`[${new Date().toISOString()}] Rolling back partial writes`);\n    await rollbackFromBackup(writtenBackups);\n    vscode.window.showErrorMessage(\n      \"Pull failed: file write error. Changes have been rolled back.\"\n    );\n    logger.appendLine(`[${new Date().toISOString()}] Pull failed: FILE_SYSTEM_ERROR`);\n    return false;\n  }\n\n  await pruneOldBackups(context);\n\n  const newLocalChecksums: Record<string, string> = {};\n  for (const file of filesToWrite) {\n    newLocalChecksums[file.syncKey] = computeChecksum(file.content);\n  }\n\n  const newState: SyncState = {\n    lastSyncTimestamp: new Date().toISOString(),\n    lastSyncDirection: \"pull\",\n    gistId: syncState.gistId,\n    localChecksums: { ...syncState.localChecksums, ...newLocalChecksums },\n    remoteChecksums: remoteChecksums,\n  };\n  await saveSyncState(context, newState);\n  clearConflicts();\n\n  checkMissingExtensions(gistData.files);\n\n  vscode.window.showInformationMessage(\n    `Pull complete: ${filesToWrite.length} file(s) updated.`\n  );\n  logger.appendLine(\n    `[${new Date().toISOString()}] Pull succeeded: ${filesToWrite.length} files`\n  );\n  return true;\n}\n\nfunction syncKeyToAbsolutePath(\n  syncKey: string,\n  roots: { cursorUser: string; dotCursor: string }\n): string | undefined {\n  if (syncKey.startsWith(\"cursor-user/\")) {\n    const rel = syncKey.slice(\"cursor-user/\".length);\n    return path.join(roots.cursorUser, ...rel.split(\"/\"));\n  }\n\n  if (syncKey.startsWith(\"dot-cursor/\")) {\n    const rel = syncKey.slice(\"dot-cursor/\".length);\n    return path.join(roots.dotCursor, ...rel.split(\"/\"));\n  }\n\n  return undefined;\n}\n\nfunction checkMissingExtensions(\n  gistFiles: Record<string, { content: string }>\n): void {\n  const extFile = gistFiles[\"cursor-user--extensions.json\"];\n  if (!extFile) {\n    return;\n  }\n\n  try {\n    const entries = JSON.parse(extFile.content) as Array<{ id: string; version: string }>;\n    const missing = findMissingExtensions(entries);\n    if (missing.length > 0) {\n      const names = missing.map((m) => m.id).join(\", \");\n      vscode.window.showInformationMessage(\n        `Extensions present remotely but not installed locally: ${names}`\n      );\n    }\n  } catch {}\n}\n", "import * as fs from \"node:fs/promises\";\nimport * as path from \"node:path\";\nimport type * as vscode from \"vscode\";\nimport { getLogger } from \"./diagnostics.js\";\n\nconst MAX_BACKUPS = 3;\n\nexport interface BackupEntry {\n  absolutePath: string;\n  backupPath: string;\n}\n\nexport async function createBackup(\n  context: vscode.ExtensionContext,\n  filePaths: string[]\n): Promise<{ backupDir: string; entries: BackupEntry[] }> {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n  const backupDir = path.join(\n    context.globalStorageUri.fsPath,\n    \"backups\",\n    timestamp\n  );\n  await fs.mkdir(backupDir, { recursive: true });\n\n  const entries: BackupEntry[] = [];\n\n  for (const absPath of filePaths) {\n    try {\n      await fs.access(absPath);\n      const relative = absPath.replace(/[/\\\\]/g, \"--\");\n      const backupPath = path.join(backupDir, relative);\n      await fs.copyFile(absPath, backupPath);\n      entries.push({ absolutePath: absPath, backupPath });\n    } catch {\n      // File doesn't exist yet, no backup needed\n    }\n  }\n\n  return { backupDir, entries };\n}\n\nexport async function rollbackFromBackup(entries: BackupEntry[]): Promise<void> {\n  const logger = getLogger();\n  for (const entry of entries) {\n    try {\n      await fs.copyFile(entry.backupPath, entry.absolutePath);\n    } catch (err) {\n      logger.appendLine(\n        `[${new Date().toISOString()}] Rollback failed for ${entry.absolutePath}: ${err instanceof Error ? err.message : String(err)}`\n      );\n    }\n  }\n}\n\nexport async function pruneOldBackups(\n  context: vscode.ExtensionContext\n): Promise<void> {\n  const backupsRoot = path.join(context.globalStorageUri.fsPath, \"backups\");\n\n  let dirs: string[];\n  try {\n    dirs = await fs.readdir(backupsRoot);\n  } catch {\n    return;\n  }\n\n  dirs.sort();\n\n  if (dirs.length <= MAX_BACKUPS) {\n    return;\n  }\n\n  const toDelete = dirs.slice(0, dirs.length - MAX_BACKUPS);\n  for (const dir of toDelete) {\n    try {\n      await fs.rm(path.join(backupsRoot, dir), { recursive: true, force: true });\n    } catch {}\n  }\n}\n", "import * as vscode from \"vscode\";\nimport { executePush, isPushLocked } from \"./push.js\";\nimport { getLogger } from \"./diagnostics.js\";\n\nconst MIN_INTERVAL_MINUTES = 5;\nconst MAX_JITTER_MS = 60_000;\n\nlet timer: ReturnType<typeof setInterval> | undefined;\nlet jitterTimeout: ReturnType<typeof setTimeout> | undefined;\n\nexport function startScheduler(context: vscode.ExtensionContext): void {\n  const config = vscode.workspace.getConfiguration(\"cursorSync\");\n  const enabled = config.get<boolean>(\"schedule.enabled\") ?? false;\n\n  if (!enabled) {\n    return;\n  }\n\n  const intervalMin = Math.max(\n    config.get<number>(\"schedule.intervalMin\") ?? 30,\n    MIN_INTERVAL_MINUTES\n  );\n  const intervalMs = intervalMin * 60 * 1000;\n  const jitter = Math.floor(Math.random() * MAX_JITTER_MS);\n\n  const logger = getLogger();\n  logger.appendLine(\n    `[${new Date().toISOString()}] Scheduler starting: interval=${intervalMin}min, jitter=${jitter}ms`\n  );\n\n  jitterTimeout = setTimeout(() => {\n    scheduledTick(context);\n    timer = setInterval(() => scheduledTick(context), intervalMs);\n  }, jitter);\n}\n\nexport function stopScheduler(): void {\n  if (jitterTimeout) {\n    clearTimeout(jitterTimeout);\n    jitterTimeout = undefined;\n  }\n  if (timer) {\n    clearInterval(timer);\n    timer = undefined;\n  }\n}\n\nasync function scheduledTick(context: vscode.ExtensionContext): Promise<void> {\n  const logger = getLogger();\n\n  if (isPushLocked()) {\n    logger.appendLine(\n      `[${new Date().toISOString()}] Scheduled sync skipped: operation in progress`\n    );\n    return;\n  }\n\n  logger.appendLine(\n    `[${new Date().toISOString()}] Scheduled sync triggered`\n  );\n\n  try {\n    await executePush(context);\n  } catch (err) {\n    logger.appendLine(\n      `[${new Date().toISOString()}] Scheduled sync failed: ${err instanceof Error ? err.message : String(err)}`\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["balanced", "maybeMatch", "range", "init_esm", "__esmMin", "a", "b", "str", "ma", "mb", "r", "reg", "m", "begs", "beg", "left", "right", "result", "ai", "bi", "i", "numeric", "str", "escapeBraces", "slashPattern", "escSlash", "openPattern", "escOpen", "closePattern", "escClose", "commaPattern", "escComma", "periodPattern", "escPeriod", "unescapeBraces", "escSlashPattern", "escOpenPattern", "escClosePattern", "escCommaPattern", "escPeriodPattern", "parseCommaParts", "parts", "m", "balanced", "pre", "body", "post", "p", "postParts", "expand", "options", "max", "EXPANSION_MAX", "expand_", "embrace", "isPadded", "el", "lte", "i", "y", "gte", "isTop", "expansions", "k", "expansion", "isNumericSequence", "isAlphaSequence", "isSequence", "isOptions", "n", "N", "x", "width", "incr", "test", "pad", "c", "need", "z", "j", "init_esm", "__esmMin", "assertValidPattern", "init_assert_valid_pattern", "__esmMin", "pattern", "posixClasses", "braceEscape", "regexpEscape", "rangesToString", "parseClass", "init_brace_expressions", "__esmMin", "ranges", "glob", "position", "pos", "negs", "sawStart", "uflag", "escaping", "negate", "endPos", "rangeStart", "WHILE", "c", "cls", "unip", "u", "neg", "r", "sranges", "snegs", "unescape", "init_unescape", "__esmMin", "windowsPathsNoEscape", "magicalBraces", "types", "isExtglobType", "isExtglobAST", "adoptionMap", "adoptionWithSpaceMap", "adoptionAnyMap", "usurpMap", "startNoTraversal", "startNoDot", "addPatternStart", "justDots", "reSpecials", "regExpEscape", "qmark", "star", "starNoEmpty", "ID", "AST", "init_ast", "__esmMin", "init_brace_expressions", "init_unescape", "c", "#root", "#hasMagic", "#uflag", "#parts", "#parent", "#parentIndex", "#negs", "#filledNegs", "#options", "#toString", "#emptyExt", "type", "parent", "options", "p", "#fillNegs", "n", "pp", "i", "part", "parts", "_a", "ret", "pl", "#parseAST", "str", "ast", "pos", "opt", "extDepth", "maxDepth", "escaping", "inBrace", "braceStart", "braceNeg", "acc", "ext", "#canAdoptType", "depthAdd", "#canAdoptWithSpace", "child", "#canAdopt", "map", "gc", "#adoptWithSpace", "index", "blank", "#adopt", "#canUsurpType", "#canUsurp", "#usurp", "m", "nt", "pattern", "glob", "re", "body", "hasMagic", "uflag", "flags", "allowDot", "dot", "#flatten", "noEmpty", "s", "src", "_", "#parseGlob", "start", "aps", "needNoTrav", "needNoDot", "end", "unescape", "repeated", "#partsToRegExp", "me", "bodyDotAllowed", "final", "close", "iterations", "done", "_hasMagic", "inStar", "needUflag", "consumed", "magic", "parseClass", "escape", "init_escape", "__esmMin", "windowsPathsNoEscape", "magicalBraces", "minimatch", "starDotExtRE", "starDotExtTest", "starDotExtTestDot", "starDotExtTestNocase", "starDotExtTestNocaseDot", "starDotStarRE", "starDotStarTest", "starDotStarTestDot", "dotStarRE", "dotStarTest", "starRE", "starTest", "starTestDot", "qmarksRE", "qmarksTestNocase", "qmarksTestNocaseDot", "qmarksTestDot", "qmarksTest", "qmarksTestNoExt", "qmarksTestNoExtDot", "defaultPlatform", "path", "sep", "GLOBSTAR", "qmark", "star", "twoStarDot", "twoStarNoDot", "filter", "ext", "defaults", "braceExpand", "makeRe", "match", "globMagic", "regExpEscape", "Minimatch", "init_esm", "__esmMin", "init_assert_valid_pattern", "init_ast", "init_escape", "init_unescape", "p", "pattern", "options", "assertValidPattern", "f", "$0", "noext", "len", "a", "b", "def", "orig", "type", "parent", "s", "list", "expand", "mm", "awe", "part", "_", "args", "rawGlobParts", "set", "__", "isUNC", "isDrive", "ss", "globParts", "i", "j", "optimizationLevel", "parts", "gs", "prev", "didSomething", "dd", "gss", "next", "p2", "other", "splin", "matched", "emptyGSMatch", "ai", "bi", "result", "which", "negate", "negateOffset", "file", "partial", "fileStartIndex", "patternStartIndex", "fileDrive", "fileUNC", "patternDrive", "patternUNC", "fdi", "pdi", "fd", "pd", "#matchGlobstar", "#matchOne", "fileIndex", "patternIndex", "firstgs", "lastgs", "head", "body", "tail", "fileHead", "fileTailMatch", "tailStart", "sawSome", "bodySegments", "currentBody", "nonGsParts", "nonGsPartsSums", "fileLength", "#matchGlobStarBodySections", "bodyIndex", "globStarDepth", "sawTail", "bs", "after", "sub", "fi", "pi", "pl", "fl", "hit", "m", "fastTest", "re", "AST", "twoStar", "flags", "pp", "filtered", "prefixes", "open", "close", "ff", "filename", "escape", "unescape", "paths_exports", "__export", "enumerateSyncFiles", "getDefaultEnabledPaths", "gistFileNameToSyncKey", "resolveSyncRoots", "syncKeyToGistFileName", "platform", "appData", "userProfile", "home", "configHome", "roots", "resolved", "config", "enabledPaths", "excludeGlobs", "maxBytes", "cursorUserGlobs", "g", "dotCursorGlobs", "entries", "collectFiles", "a", "b", "rootDir", "prefix", "includeGlobs", "result", "dirExists", "allFiles", "walkDirectory", "absPath", "rel", "isDenylisted", "minimatch", "relativePath", "parts", "topDir", "DENYLIST_DIRS", "fileName", "DENYLIST_FILES", "glob", "DENYLIST_GLOBS", "dir", "results", "entry", "fullPath", "sub", "p", "syncKey", "gistFileName", "path", "fs", "os", "vscode", "init_paths", "__esmMin", "init_esm", "extension_exports", "__export", "activate", "deactivate", "__toCommonJS", "vscode", "vscode", "GITHUB_API", "USER_AGENT", "GistClient", "pat", "gistId", "files", "description", "method", "endpoint", "body", "transform", "url", "headers", "response", "err", "rateLimitRemaining", "retryAfterHeader", "errorMessage", "errorBody", "data", "NON_RETRYABLE_CODES", "withRetry", "fn", "lastError", "attempt", "result", "delay", "sleep", "ms", "resolve", "vscode", "fs", "path", "outputChannel", "getLogger", "showStatus", "context", "syncState", "loadSyncState", "items", "getSyncStatePath", "filePath", "data", "saveSyncState", "state", "dir", "SECRET_KEY", "configureGithub", "context", "logger", "getLogger", "pat", "value", "client", "GistClient", "result", "withRetry", "getToken", "requireToken", "token", "validateStoredToken", "vscode", "fs", "init_paths", "crypto", "fs", "os", "packageFiles", "files", "profileName", "sorted", "b", "packaged", "manifestFiles", "file", "buf", "isUtf8", "isValidUtf8", "content", "checksum", "sizeBytes", "entry", "manifestEntry", "manifest", "computeMachineId", "computeChecksum", "raw", "vscode", "fs", "init_paths", "pendingResolutions", "pendingConflicts", "clearConflicts", "pendingConflicts", "pendingResolutions", "detectConflicts", "context", "remoteChecksums", "syncState", "loadSyncState", "localFiles", "enumerateSyncFiles", "localChecksums", "file", "buf", "computeChecksum", "conflicts", "allKeys", "key", "baseLocal", "baseRemote", "currentLocal", "currentRemote", "resolveConflictsCommand", "logger", "getLogger", "resolutions", "conflict", "choice", "r", "getResolutionForKey", "vscode", "generateExtensionsJson", "extensions", "entries", "ext", "kind", "a", "b", "findMissingExtensions", "remoteEntries", "installedIds", "entry", "pushLock", "isPushLocked", "executePush", "context", "logger", "getLogger", "doPush", "validateStoredToken", "requireToken", "token", "client", "GistClient", "syncState", "loadSyncState", "remoteChecksums", "conflicts", "detectConflicts", "unresolved", "c", "resolution", "getResolutionForKey", "extensionsJson", "generateExtensionsJson", "cursorUserRoot", "extensionsPath", "writeExtensionsFile", "files", "enumerateSyncFiles", "profileName", "packaged", "manifest", "packageFiles", "gistFiles", "key", "value", "gistFileName", "syncKeyToGistFileName", "gistId", "existingResult", "withRetry", "filesToDelete", "existingFiles", "existing", "updatePayload", "result", "checksums", "newState", "saveSyncState", "clearConflicts", "fileCount", "content", "filePath", "dir", "vscode", "fs", "path", "init_paths", "fs", "path", "MAX_BACKUPS", "createBackup", "context", "filePaths", "timestamp", "backupDir", "entries", "absPath", "relative", "backupPath", "rollbackFromBackup", "logger", "getLogger", "entry", "err", "pruneOldBackups", "backupsRoot", "dirs", "toDelete", "dir", "pullLock", "executePull", "context", "logger", "getLogger", "doPull", "syncState", "loadSyncState", "token", "requireToken", "client", "GistClient", "gistResult", "withRetry", "gistData", "manifestFile", "manifest", "remoteChecksums", "key", "entry", "conflicts", "detectConflicts", "unresolved", "c", "resolution", "getResolutionForKey", "roots", "resolveSyncRoots", "filesToWrite", "gistFileName", "gistFile", "syncKey", "gistFileNameToSyncKey", "manifestEntry", "absolutePath", "syncKeyToAbsolutePath", "content", "items", "f", "selected", "selectedKeys", "s", "filtered", "backupEntries", "createBackup", "writtenBackups", "writeError", "file", "dir", "tmpPath", "backup", "b", "err", "rollbackFromBackup", "pruneOldBackups", "newLocalChecksums", "computeChecksum", "newState", "saveSyncState", "clearConflicts", "checkMissingExtensions", "rel", "gistFiles", "extFile", "entries", "missing", "findMissingExtensions", "names", "m", "vscode", "MIN_INTERVAL_MINUTES", "MAX_JITTER_MS", "timer", "jitterTimeout", "startScheduler", "context", "config", "intervalMin", "intervalMs", "jitter", "getLogger", "scheduledTick", "stopScheduler", "logger", "isPushLocked", "executePush", "err", "configListener", "activate", "context", "logger", "getLogger", "configureGithub", "executePush", "executePull", "showStatus", "resolveConflictsCommand", "updateConfiguredContext", "startScheduler", "stopScheduler", "deactivate", "token", "getToken"]
}
